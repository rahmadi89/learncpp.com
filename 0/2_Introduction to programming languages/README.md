<h1> مقدمه‌ای بر زبان‌های برنامه‌نویسی </h1>

<div dir="rtl">
<p align="justify">
کامپیوترهای مدرن به طرز شگفت‌انگیزی سریعن و در حال سریعتر شدن هم هستن. اگهرچه کامپیوترها محدودیت‌ها مهمی دارن: به صورت ذاتی! (natively) فقط تعداد محدودی دستور رو میفهمن و باید خیلی دقیق بهشون بگی که چیکار کنن.


یک **برنامه کامپیوتری** (که بهش **اپلیکیشن** میگن) یه مجموعه دستورالعمله که کامپیوتر میتونه برای انجام یه وظیفه خاص اجراشون کنه. فرآیند ساخت این برنامه اسمش میشه **برنامه‌نویسی**. برنامه‌نویس‌ها معمولا با کدنویسی این برنامه‌‌ها رو تولید می کنن که یه لیستی از دستوراتیه که توی یک یا چند تا فایل تایپ میشه

اون بخش‌های فیزیکی کامپیوتر که کامپیوتر رو تشکیل میدن و برنامه‌ها رو اجرا می‌کنن اسمشون **سخت‌افزار** هست. وقتی برنامه توی حافظه بارگذاری شد و سخت‌افزار به طور متوالی (sequentially) شروع کرد به اجرای دستورالعمل‌ها، به این کار میگن اجرای برنامه (running or executing).
</p>


<h2> زبان ماشین </h2>
<p align="justify">
یک CPU قابلیت صحبت کردن با زبان C++ رو نداره. دستورات محدودی که CPU میتونه اونه رو بفهمه با نام کد ماشین یا زبان ماشین یا مجموعه دستورات شناخته میشن.
به عنوان مثال یک نمون از این دستورات: `10110000 01100001`
قدیم‌ها وقتی کامپیوتر تازه اختراع شده بود، برنامه‌نویس‌ها مجبور بودن مستقیما به زبان ماشین، که بسیار سخت و وقت‌گیر بود برنامه بنویسن.

اینکه چطور این دستورات کار می‌کنن فراتر از مباحث این آموزشه، اما ذکر دو مورد خالی از لطف نیست. اول، هر دستورالعمل از مجموعه‌ای از 0 و 1 تشکیل شده. هر کدوم از 0 یا 1 ها، یک **binary digit** یا به اختصار **bit** نامیده میشن.
تعداد بیت‌های تشکیل دهنده یک دستورالعمل یکسان نیست و برای هر CPU میتونه متفاوت باشه. به عنوان مثال بعضی CPU ها همیشه دستورالعمل‌هاشون 32 بیته در حالی که بعضیای دیگه دستورالعمل‌هایی دارن که طولشون میتونه متغیر باشه (مثل خونواده x86)
دوم، هر دستورالعمل باینری توسط CPU به یک command تفسیر میشه که یک کار خاصی رو انجام میده، مثل مقایسه دو عدد، یا جا گذاری یه عدد در یک قسمت حافظه. از اونجا که CPUها دستورالعمل‌های متفاوتی دارن، پس دستورالعملی که برای یک CPU نوشه شده
نمی‌تونه برای یه CPU دیگه که اون دستورالعمل رو نداره استفاده بشه. این جمله به این معنیه که در حالت کلی برنامه‌ها پرتابل (**Portable**) نیستن و نمی‌تونن توی سیستم‌‌های مختلف (بدون تغییرات خیلی زیاد) اجرا بشن و مجبوریم کل برنامه رو دوباره بنویسیم.
</p>

<h2> زبان اسمبلی </h2>

<p align="justify">
از اونجا که خوندن و نوشتن به زبان ماشین برای انسان خیلی سخت بود، زبان اسمبلی اختراع شد. در زبان اسمبلی هر دستور با یک کلمه مخفف (به جای مجموعه‌‌ای از بیت‌ها) مشخص میشه و میشه از نام‌ها و اعداد هم استفاده کرد.
به عنوان مثال: `mov al, 061h`
این کار باعث میشه اسمبلی خیلی خیلی بیشتر از زبان ماشین قابل خواندن و نوشتن باشه. از اونجا که CPU نمیتونه مستقیما زبان اسمبلی رو بفهمه، پس زبان اسمبلی باید به زبان ماشین ترجمه بشه. این کار رو برنامه ای به اسم **اسمبلر** (**assembler**) انجام میده.
برنامه‌های اسمبلی خیلی سریع اجرا میشن تا حدی که حتی امروزه هم اونجایی که سرعت حیاتیه از اسمبلی استفاده میشه.

مثل هر چیز دیگه‌ای اسمبلی هم یه یه روی تاریکی داره! اول اینکه برای انجام یه تسک ساده هم یه عالمه دستور باید بنویسیم. درسته که دستوراتش برای انسان خواناتره اما فهمیدن اینکه کل برنامه داره چیکار می‌کنه هنوز سخته (مثل اینه که بخوای یه جمله رو با نگاه به تک تک کلمات به صورت اختصاصی بفهمی)
دوم اینکه خیلی پرتابل نیست، برنامه‌ای که به زبان اسمبلی برای یه CPU نوشته شده معمولا روی یه CPU دیگه کار نمی‌‌کنه و باید از اول نوشته بشه.
</p>

<h2> برنامه‌های سطح بالا </h2>
برای رفع مشکل خوانایی و پرتابل بودن، زبان‌های جدیدی مثل C، C++ و Pascal (و اخیرا جاوا، جاوا اسکریپ و Perl و...) بوجود اومدن. این زبان‌‌ها زبان‌‌های سطح بالا (High-Level Languages) نامیده میشن که به برنامه‌نویس کمک می‌کنن برنامه‌ای بنویسن بدون نگرانی از اینکه 
قراره توی چه نوع کامپیوتری اجرا بشه.
به عنوان مثال در زبان C/C++: `a = 97;`


درست مثل زبان اسمبلی، برنامه‌‌هایی که با زبان‌های سطح بالا نوشته میشن هم لازمه ک به زبان ماشین ترجمه بشن تا بتونن اجرا بشن. دو راه داریم: کامپایل کردن (Compiling) و تفسیر کردن (Interpreting)

**کامپایلر** برنامه‌ایه که سورس کد رو میخونه و یه فایلی ایجاد می‌کنه که میتونه اجرا بشه. وقتی این فایله ایجاد شد دیگه نیازی به کامپایلر نیست و خودش به تنهایی میتونه اجرا بشه.
اوایل که هنوز کامپایلرها تازه کار بودن، کدهای کند و غیربهینه تولید می‌کردن. به مرور زمان، کارشون اینقدر خوب شد و کدهای سریع و بهینه تولید کردن که تو بعضی موارد حتی کدهای اسمبلی بهتری از انسان تولید می‌کنن!

یک نمای ساده از فرآیند کامپایل:

 



</div>